# Здание 2

## Условие

В рамках здания необходимо собрать данные (id vk), у всех своих одногруппников, в один csv-файл, после чего найти друзей и друзей друзей (**ограничение:** берем первых 100 друзей на каждом уровне). 
После нахождения всех друзей удаляем дублирующиеся связи и строим граф. Для построения графа предпочтительно использовать [Cosmograph](https://cosmograph.app/). 
После построения графа необходимо просчитать центральности графа (центральность по степени, центральность по посредничеству, центральность по близости).

## Решение

### Сбор данных из ВКонтакте. 

Перед началом сбора данных необходимо зарегистрироваться как разработчик и создать своё Standalone-приложение, а также получить ключ доступа [Инструкция](https://dev.vk.com/ru/api/getting-started).
После получения ключа доступа и создания Standalone-приложения создадим хранимую процедуру, чтобы у нас была возможность выгружать данные нескольких пользователей сразу. 
У API ВКонтакте есть ограничение по времени и количеству отправляемых запросов. Подробнее можно ознакомиться можно [тут](https://dev.vk.com/ru/api/api-requests). 
чтобы обойти данное ограничение напишем небольшую процедуру *getFriendsById*.

```
var id = Args.userId.split(',');

var friends = [];
var i = 0;
while (id.length > i && i < 25)
{
  var temp = API.users.get({"user_ids":id[i]});
  if(temp@.is_closed[0] || temp@.deactivated[0] == "banned" ||temp@.deactivated[0] == "deleted") {
    friends.push(null);
  }
  else{
    friends.push( API.friends.get({"user_id": id[i], "count": "100"}).items);
  }
  i = i + 1;
}
return friends;
```

На вход мы передаем список id пользователей в виде строки, каждый id разделен запятой. В качестве ответа получаем json массив, содержащий друзей для запрашиваемых id, по их порядку передачи.

### Сохранение результатов

Полученный результат записываем в файл, структура которого следующая \# помечается id-пользователя чьи друзья будут перечислены ниже.
Пример:
```
#2132
2124
2132
4133
#1233
```

В Результате получим три файла формата .txt (lvl0, lvl1, lvl2).
После удачного сохранения данных в файлы объединим их и удалим лишние ребра.

### Построение графа

После того, как все ребра графа были найдены, сохраним их в .CSV формате. Для именования левой колонки используем слово source, а для правой target. перейдем на сайт [Cosmograph](https://cosmograph.app/) и загрузим результат. В итоге получаем граф, представленный ниже.

![photo_2024-10-30_15-17-41](https://github.com/user-attachments/assets/ecdea8eb-33fc-49ba-a061-1595ea7753fd)

### Расчет центральностей

Для расчета центральностей воспользуемся кодом на Python представленном ниже.

```Python
import networkx as nx

G = nx.Graph()

counte = 0

for i in open('EdgesAll.txt'):
    counte += 1
    node = list(map(int, i.split(',')))
    G.add_edge(node[0], node[1])

print("Центральность по степени")

characters = sorted(list(nx.degree_centrality(G).items()), key=lambda i: i[1], reverse=True)

print(*characters[:10], sep='\n')

print("Центральность по посредничеству")

characters = sorted(list(nx.betweenness_centrality(G).items()), key=lambda i: i[1], reverse=True)

print(*characters[:10], sep='\n')

print("Центральность по близости")

characters = sorted(list(nx.closeness_centrality(G).items()), key=lambda i: i[1], reverse=True)

print(*characters[:10], sep='\n')
```

